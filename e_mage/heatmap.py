from scipy.ndimage import gaussian_filter
from scipy.spatial import distance
import numpy as np
import matplotlib.pyplot as plt
import os
import cv2

def generate_gaussmap(sigma: int, truncate: int = 4, max_value: float = 1.0, order: int = 0):
    '''Genarate a heatmap-like array.
    Args:
        sigma (int): The standard deviation for the Gaussian kernel.
        truncate (int): Truncate the filter at this many standard deviations.
        max_value (float): The peak value for the heatmap.
        order (int): A positive order corresponds to convolution with that derivative of a Gaussian.
    Returns:
        gaussmap (numpy_array): The heatmap-like array.
    Examples:
        >>> generate_gaussmap(6)
    '''
    sq_shape = sigma * truncate * 2 + 1
    sq_center = sigma * truncate + 1
    blk = np.zeros((sq_shape + 2, sq_shape + 2))
    blk[sq_center + 1, sq_center + 1] = 1

    # The radius of the Gaussian kernel is int(sigma*truncate+0.5).
    gauss = gaussian_filter(blk, sigma=sigma, order=order, truncate=truncate, mode='constant')
    gauss = gauss / gauss.max() * max_value
    nz = np.where(gauss != 0)  # non-zero region.
    gaussmap = gauss[nz[0].min():nz[0].max(), nz[1].min():nz[1].max()]
    return gaussmap


def generate_heatmap_sequence(seq, ishape: tuple, gpath: str, save_dir: str = '', save_type: str = 'npy'):
    '''get heatmaps of sequence data
    Args:
        points (numpy.ndarray or list): Object coordinates [[t1, x1, y1], [t1, x2, y2], ...]
        shape (tuple): Image shape (H, W)
        gpath (str): Path of 2D gauss map generated by generate_gaussmap
        save_dir (str): Save directory path
    Return:
        heatmap (numpy array): heatmap
    Example:
        >>> generate_heatmap_sequence(seq, (100, 100), './gauss_array/sigma01_float64.npy')
    '''

    seq = np.array(seq) if type(seq) is not np.ndarray else seq
    gauss = np.load(gpath)

    iH, iW = ishape
    gH, gW = gauss.shape
    pHs, pWs = np.where(gauss == gauss.max())
    py, px = np.average([pHs, pWs], axis=1).astype('int')

    zeromap = np.zeros((iH + int(gH / 2) * 2, iW + int(gW / 2) * 2))

    frames = np.unique(seq[:, 0])
    buf_seq = seq.copy()
    buf_seq = buf_seq + np.array([[0, int(gW / 2) - px, int(gH / 2) - py]])
    for frame in frames:
        heatmap = zeromap.copy()
        points = buf_seq[buf_seq[:, 0] == frame]
        for _, x, y in points:
            gaussmap = zeromap.copy()
            gaussmap[y:y + gH, x:x + gW] = gauss
            heatmap = np.maximum(heatmap, gaussmap)
        heatmap = heatmap[int(gH / 2):-int(gH / 2), int(gW / 2):-int(gW / 2)]
        if len(save_dir):
            if save_type == 'npy':
                np.save(os.path.join(save_dir, f'{frame:04}.npy'), heatmap)
            elif save_type == 'png':
                heatmap = ((heatmap / heatmap.max()) * 255).astype('uint8')
                cv2.imwrite(os.path.join(save_dir, f'{frame:04}.png'), heatmap)


def generate_voronoi_vectormap(tracklets, ishape: tuple, itv: int = 1):
    '''
    Args:
        tracklets (): [[frame, id, x, y]]
    '''

    # tracklets = np.array(tracklets) if type(tracklets) is np.ndarray else tracklets
    #
    # iH, iW = ishape
    # coords = np.array([[int(p/iH), iW%p] for p in range(iH*iW)])
    # frames = np.unique(tracklets)
    #
    # for frame in frames:
    #     source = tracklets[tracklets[:,0]==frame]
    #     target = tracklets[tracklets[:,0]==frame+itv]
    #     if len(target):
    #         dmap = distance.cdist(source[:,2:4][...,None], coords[None], metric='euclidean')
    #         s_idcs = np.argmin(dmap, axis=0)
    pass

def generate_MPM():
    pass
